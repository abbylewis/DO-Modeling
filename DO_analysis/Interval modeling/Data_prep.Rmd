---
title: "DO intervals"
author: "Abby Lewis"
date: "8/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(rLakeAnalyzer)
```


```{r}
# Load in CTD data
ctd <- read.csv("../../DO_modeling_data/CTD_final_2013_2020.csv")

# Load in bathymetry data
vol <- read_csv("../../DO_modeling_data/FCR Bathymetry.csv")
colnames(vol) <- c("Depth_m","Volume_L","SA_m2")

# Create a dataframe of oxygenation interval dates
turnover <- read_csv("../../DO_modeling_data/TurnoverDates_22Oct18.csv")
turnover <- turnover %>%
  mutate(Date_turnover = as.Date(turnover$Date, format = "%m/%d/%y"))%>%
  dplyr::select(-Date)
turnover$Date_turnover[!is.na(turnover$Year)&turnover$Year==2018]<- as.Date("2018-10-16") #because oxygen increases after this
turnover$Date_turnover[!is.na(turnover$Year)&turnover$Year==2019]<- as.Date("2019-10-23") #because oxygen increases faster after this and co2 declines
intGuide <- read_csv("../../DO_modeling_data/Hox_schedule_ungrouped.csv") %>%
  mutate(Year=year(Start),
         Start = as.Date(Start),
         End = as.Date(End)) %>%
  left_join(turnover %>% dplyr::select(-For2018,-Time)) %>%
  filter(Start<Date_turnover)
intGuide$End[is.na(intGuide$End)] <- intGuide$Date_turnover[is.na(intGuide$End)]
intGuide$End[intGuide$End>intGuide$Date_turnover] <- intGuide$Date_turnover[intGuide$End>intGuide$Date_turnover]
intGuide$Days = as.numeric(difftime(intGuide$End, intGuide$Start), units = "days")
```

Creating a dataset that is all of the CTD data but only at depths from bathymetry
```{r}
dt1 <- ctd
dt1$Date <- as.POSIXct(dt1$Date)
dt1_culled <- dt1 %>%
  filter(Site == 50 & Reservoir == "FCR" & !is.na(DO_mgL))

depths <- vol$Depth_m
# (Depths Can be changed as necessary)
df.final2<-dt1_culled %>% group_by(Date) %>% slice(which.min(abs(as.numeric(Depth_m) - depths[1]))) #Create a new dataframe
df.final2$Depth_m <- depths[1]
for (j in 2:length(depths)){ #loop through all depths and add the closest values to the final dataframe
  ctd_atThisDepth <- dt1_culled %>% group_by(Date) %>% slice(which.min(abs(as.numeric(Depth_m) - depths[j])))
  ctd_atThisDepth$Depth_m <- depths[j]
  df.final2 <- rbind(df.final2,ctd_atThisDepth)
}

thermo <- df.final2 %>%
  arrange(Date) %>%
  summarize(meta_bottom = meta.depths(Temp_C, Depth_m)[2],
            schmidt_stability = schmidt.stability(Temp_C, Depth_m, vol$SA_m2, vol$Depth_m))
mean(thermo$meta_bottom, na.rm = T) #5.31


#### IF YOU WANT A CONSTANT THERM DEPTH USE THIS
#thermo$meta_bottom<- 6 #Using constant thermocline depth
```

Creating a dataframe based upon the CTD data that calculates the volume-weighted hypolimnetic DO concentrations
```{r}
vw <- df.final2 %>%
  filter(!as.Date(Date) %in% as.Date(c("2017-07-06", "2017-08-27","2017-09-03"))) %>% ### These look like BVR casts
  group_by(Date) %>%
  left_join(thermo, by = "Date") %>%
  mutate(Thermocline = meta_bottom) %>% 
  ungroup() %>%
  left_join(vol, by = "Depth_m")%>%
  mutate(DO_Weighted = DO_mgL*Volume_L,
         TP_Weighted = Temp_C*Volume_L) %>%
  filter(Depth_m >= Thermocline,) %>%
  group_by(Date) %>%
  summarize(
    thermo_depth = unique(Thermocline),
    Vol_Weighted_DO = sum(DO_Weighted),
    hypoVolume = sum(Volume_L),
    Conc = Vol_Weighted_DO/hypoVolume,
    Temp = sum(TP_Weighted)/hypoVolume,
    Temp_sed = last(Temp_C),
    Chla_ugL = mean(Chla_ugL),
    SA_m2 = mean(SA_m2),
    schmidt_stability = unique(schmidt_stability))

write.csv(vw, "../../DO_modeling_data/vol_weighted_do_fcr_28Aug.csv")
```

Adding VW YSI data (for 2017)
```{r}
#Load in YSI data
ysi <- read.csv("../../DO_modeling_data/YSI_PAR_profiles_2013-2020.csv")
ysi = ysi%>%
  filter(Reservoir == "FCR",
         Site == 50,
         !is.na(DO_mgL))

ghg_depths <- c(0.1, 1.6, 3.8, 5, 6.2, 8, 9)
lower = 0
upper = ghg_depths[1]+(ghg_depths[2]-ghg_depths[1])/2
ghg_vols = c(sum(vol$Volume_L[vol$Depth_m < upper & vol$Depth_m > lower]))
ghg_layer_depth <- c()
ghg_layer_depth[1] <- upper-lower
for (d in 2:length(ghg_depths)){
  lower = ghg_depths[d]-(ghg_depths[d]-ghg_depths[d-1])/2
  upper = ghg_depths[d]+(ghg_depths[d+1]-ghg_depths[d])/2
  if(d == length(ghg_depths-1)){upper = 9.3}
  ghg_vols = c(ghg_vols, sum(vol$Volume_L[vol$Depth_m < upper & vol$Depth_m > lower]))
  ghg_layer_depth[d] <- upper-lower
}
vol2 = data.frame(ghg_depths,ghg_vols, ghg_layer_depth)

thermo = ysi%>%
  filter(Depth_m > 0,
         !is.na(Temp_C))%>%
  group_by(DateTime,Depth_m)%>%
  summarize(Temp_C = mean(Temp_C))%>%
  summarize(meta_bottom = meta.depths(Temp_C, Depth_m)[2],
            schmidt_stability = schmidt.stability(Temp_C, Depth_m, vol$SA_m2, vol$Depth_m),
            n = n())%>%
  filter(n>1)

thermo%>%
  filter(year(as.Date(DateTime))==2017,
         !is.na(meta_bottom))%>%
  ggplot(aes(x = as.Date(DateTime), y = meta_bottom))+
  geom_line()

ysi_flex = ysi %>%
  full_join(thermo, by = "DateTime")

ysi_interpolated <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(ysi_interpolated) <- c("DateTime","Depth_m","DO_mgL","Temp_C")
ysi_interpolated$DateTime<-as.character(ysi_interpolated$DateTime)
for(date in unique(ysi_flex$DateTime)){
  today = ysi_flex[ysi_flex$DateTime == date,]
  if(!is.na(unique(today$meta_bottom))){
    do = approx(today$Depth_m, today$DO_mgL, xout = vol$Depth_m, yright = 2)
    temp = approx(today$Depth_m, today$Temp_C, xout = vol$Depth_m, yright = 2)
    new = data.frame(do[1], do[2],temp[2])
    colnames(new)<-c("Depth_m","DO_mgL","Temp_C")
    new$DateTime = date
    ysi_interpolated = ysi_interpolated%>%
      full_join(new)
  }
}

ysi_interpolated_vw = ysi_interpolated%>%
  group_by(DateTime) %>%
  left_join(thermo, by = "DateTime") %>%
  mutate(Thermocline = meta_bottom) %>% 
  ungroup() %>%
  left_join(vol, by = "Depth_m")%>%
  mutate(DO_Weighted = DO_mgL*Volume_L,
         TP_Weighted = Temp_C*Volume_L) %>%
  filter(Depth_m >= Thermocline,) %>%
  group_by(DateTime) %>%
  summarize(
    thermo_depth = unique(Thermocline),
    Vol_Weighted_DO = sum(DO_Weighted),
    hypoVolume = sum(Volume_L),
    Conc = Vol_Weighted_DO/hypoVolume,
    Temp = sum(TP_Weighted)/hypoVolume,
    Temp_sed = last(Temp_C),
    SA_m2 = mean(SA_m2),
    schmidt_stability = unique(schmidt_stability))%>%
  mutate(DateTime = as.POSIXct(DateTime))

ysi_vw = ysi %>%
  full_join(vol2, by = c("Depth_m"="ghg_depths")) %>%
  filter(Depth_m %in% c(6.2, 8, 9)) %>%
  mutate(Date = as.Date(DateTime),
         DO_Weighted = DO_mgL*ghg_vols,
         TP_Weighted = Temp_C*ghg_vols)%>%
  group_by(Date)%>%
  mutate(n = length(unique(Depth_m)))%>%
  filter(n == 3)%>%
  summarize(hypoVolume = sum(ghg_vols),
            Conc = sum(DO_Weighted)/hypoVolume,
            Temp = sum(TP_Weighted)/hypoVolume)

vw_with_ysi = vw%>%
  mutate(Source = "CTD")%>%
  full_join(ysi_interpolated_vw%>% mutate(Source = "YSI")%>%filter(year(DateTime)==2017)%>%rename(Date = DateTime))

#2017-08-02 12:00:00
#2017-08-06 12:00:00
#2017-08-09 12:00:00
#2017-08-13 12:00:00
#2017-08-16 12:00:00
#2017-10-23 12:00:00	8	0.6929797	#Two profiles on the same day with different temperatures. This "12:00" one isn't in the datasheet on 2025 desktop
#Just about all of the inflow readings are coded as site 50

ysi%>%
  filter(year(as.Date(DateTime))==2017)%>%
  group_by(DateTime)%>%
  mutate(n = n())%>%
  filter(n == 1)
  

ysi%>%
  mutate(DateTime= as.Date(DateTime))%>%
  filter(year(DateTime)==2013)
```


Formatting data: this is necessary REGARDLESS of whether you are doing weekly or whole-interval
```{r}
vw2 <- vw_with_ysi
vw <- vw_with_ysi

#Creates the dataframe with background information for each interval (start, end, SSS, etc)

vw2$ClosestStart <- NA
vw2$DaysSinceStart <- NA
vw2$Date <- as.Date(vw2$Date)
vw2$SSS <- NA
vw2$scfm <- NA
vw2$IntervalStart <- as.Date(NA)
vw2$IntervalEnd <- as.Date(NA)
for(i in seq(1:nrow(vw2))){
  distance <- as.numeric(difftime(vw2$Date[i], intGuide$Start, units = "days"))
  distance[distance<0] <- NA
  if(all(is.na(distance))){
    vw2$ClosestStart[i] <- 0
  } else {
      vw2$ClosestStart[i] <- which.min(distance)
      vw2$IntervalStart[i] <- intGuide$Start[which.min(distance)]
      vw2$IntervalEnd[i] <- intGuide$End[which.min(distance)]
      vw2$DaysSinceStart[i] <- min(distance, na.rm = TRUE)
      vw2$SSS[i] <- as.character(intGuide$SSS[which.min(distance)])
      vw2$scfm[i] <- intGuide$scfm[which.min(distance)]
      distanceEnd <- as.numeric(difftime(vw2$Date[i], intGuide$End, units = "days"))
      distanceEnd[distanceEnd<=0] <- NA
      if(min(distance, na.rm = TRUE) > min(distanceEnd, na.rm = TRUE)) { #Getting rid of points after the end of the season
            vw2$ClosestStart[i] <- NA
            vw2$DaysSinceStart[i] <- NA
            vw2$SSS[i] <- NA
            vw2$scfm[i] <- NA
            vw2$IntervalStart[i] <- NA
            vw2$IntervalEnd[i] <- NA
    }
  }
}

#Creates an additional dataframe to join with vw2. 
#fixEndpoints has only the end dates and it adds them at the END of the correct interval, since they will otherwise be processed only as the beginning point of the next one

fixEndpoints <- vw2 %>%
  filter(DaysSinceStart == 0)
for(i in seq(1:nrow(fixEndpoints))){
  distance <- as.numeric(difftime(fixEndpoints$Date[i], intGuide$Start, units = "days"))
  distance[distance<0] <- NA
  distance[distance == fixEndpoints$DaysSinceStart[i]] <- NA
  if(all(is.na(distance))){
    fixEndpoints$ClosestStart[i] <- 0
  } else {
      fixEndpoints$ClosestStart[i] <- which.min(distance)
      fixEndpoints$IntervalStart[i] <- intGuide$Start[which.min(distance)]
      fixEndpoints$IntervalEnd[i] <- intGuide$End[which.min(distance)]
      fixEndpoints$DaysSinceStart[i] <- min(distance, na.rm = TRUE)
      fixEndpoints$SSS[i] <- as.character(intGuide$SSS[which.min(distance)])
      fixEndpoints$scfm[i] <- intGuide$scfm[which.min(distance)]
      distanceEnd <- as.numeric(difftime(fixEndpoints$Date[i], intGuide$End, units = "days"))
      distanceEnd[distanceEnd<=0] <- NA
      if(min(distance, na.rm = TRUE) > min(distanceEnd, na.rm = TRUE)) {
            fixEndpoints$ClosestStart[i] <- NA
            fixEndpoints$DaysSinceStart[i] <- NA
            fixEndpoints$SSS[i] <- NA
            fixEndpoints$scfm[i] <- NA
            fixEndpoints$IntervalStart[i] <- NA
            fixEndpoints$IntervalEnd[i] <- NA
    }
  }
}
vw2 = vw2 %>%
  full_join(fixEndpoints)%>%
  mutate(Year = year(Date))%>%
  left_join(turnover, by = "Year") %>%
  filter(Date<Date_turnover) %>%
  dplyr::select(-Time,-For2018,-Year)
```

Adding supplemental data
```{r}
#Loading GHG data
ghgs<- read.csv("../../DO_modeling_data/Dissolved_CO2_CH4_Virginia_Reservoirs.csv")
fcr_ghgs = ghgs%>%filter(Reservoir == "FCR", 
              Site == 50)%>%
  mutate(Date = as.Date(DateTime))

# Bathymetry
vol <- read_csv("../../DO_modeling_data/FCR Bathymetry.csv")
colnames(vol) <- c("Depth_m","Volume_L","SA_m2")

#Iron
metals <- read.csv("../../DO_modeling_data/metals_EDI_current.csv")%>%
  filter(Reservoir == "FCR",
         Site == 50)%>%
  mutate(Date = as.Date(DateTime, format = "%m/%d/%Y %H:%M:%S"))

#DOC
chemistry <- read.csv("../../DO_modeling_data/chemistry.csv")%>%
  filter(Reservoir == "FCR",
         Site == 50)%>%
  mutate(Date = as.Date(DateTime))

ghg_depths <- c(0.1, 1.6, 3.8, 5, 6.2, 8, 9)
lower = 0
upper = ghg_depths[1]+(ghg_depths[2]-ghg_depths[1])/2
ghg_vols = c(sum(vol$Volume_L[vol$Depth_m < upper & vol$Depth_m > lower]))
ghg_layer_depth <- c()
ghg_layer_depth[1] <- upper-lower
for (d in 2:length(ghg_depths)){
  lower = ghg_depths[d]-(ghg_depths[d]-ghg_depths[d-1])/2
  upper = ghg_depths[d]+(ghg_depths[d+1]-ghg_depths[d])/2
  if(d == length(ghg_depths-1)){upper = 9.3}
  ghg_vols = c(ghg_vols, sum(vol$Volume_L[vol$Depth_m < upper & vol$Depth_m > lower]))
  ghg_layer_depth[d] <- upper-lower
}
vol2 = data.frame(ghg_depths,ghg_vols, ghg_layer_depth)

fcr_fe_formatted = metals %>%
  mutate(Depth_m = as.numeric(Depth_m)) %>%
  full_join(vol2, by = c("Depth_m"="ghg_depths")) %>%
  filter(Reservoir == "FCR", Depth_m %in% c(0.1, 1.6, 3.8, 5, 6.2, 8, 9)) %>%
  group_by(Date, Depth_m)%>%
  summarise(TFe_mgL_sd = sd(TFe_mgL),
            TFe_mgL = mean(TFe_mgL, na.rm = T),
            layer_vol = unique(ghg_vols),
            layer_depth = unique(ghg_layer_depth)) %>%
  filter(Depth_m>6)%>%
  group_by(Date)%>%
  mutate(n = length(unique(Depth_m)))%>%
  filter(n == 3)%>%
  mutate(fe_in_layer = TFe_mgL*layer_vol)%>%
  summarize(TFe_mgL = sum(fe_in_layer)/sum(layer_vol))

fcr_doc_formatted = chemistry %>%
  mutate(Depth_m = as.numeric(Depth_m)) %>%
  full_join(vol2, by = c("Depth_m"="ghg_depths")) %>%
  filter(Reservoir == "FCR", 
         Depth_m %in% c(0.1, 1.6, 3.8, 5, 6.2, 8, 9), 
         DOC_mgL < 10) %>% #Simplistic form of QAQC
  group_by(Date, Depth_m)%>%
  summarise(DOC_mgL = mean(DOC_mgL, na.rm = T),
            layer_vol = unique(ghg_vols),
            layer_depth = unique(ghg_layer_depth)) %>%
  filter(Depth_m>6)%>%
  group_by(Date)%>%
  mutate(n = length(unique(Depth_m)))%>%
  filter(n == 3)%>%
  mutate(doc_in_layer = DOC_mgL*layer_vol)%>%
  summarize(DOC_mgL = sum(doc_in_layer)/sum(layer_vol))%>%
  filter(!is.na(DOC_mgL))

fcr_ghg_formatted = fcr_ghgs %>%
  mutate(Depth_m = as.numeric(Depth_m)) %>%
  full_join(vol2, by = c("Depth_m"="ghg_depths")) %>%
  filter(Reservoir == "FCR", Depth_m %in% c(0.1, 1.6, 3.8, 5, 6.2, 8, 9)) %>%
  group_by(Date, Depth_m)%>%
  summarise(ch4_sd = sd(ch4_umolL),
            co2_sd = sd(co2_umolL),
            ch4_umolL = mean(ch4_umolL, na.rm = T),
            co2_umolL = mean(co2_umolL, na.rm = T),
            layer_vol = unique(ghg_vols),
            layer_depth = unique(ghg_layer_depth)) %>%
  filter(Depth_m>6)%>%
  group_by(Date)%>%
  mutate(n = length(unique(Depth_m)))%>%
  filter(n == 3)%>%
  mutate(co2_in_layer = co2_umolL*layer_vol,
         ch4_in_layer = ch4_umolL*layer_vol)%>%
  summarize(co2_vw_umolL = sum(co2_in_layer)/sum(layer_vol),
            ch4_vw_umolL = sum(ch4_in_layer)/sum(layer_vol))

fcr_fe_formatted%>%
  ggplot(aes(x = Date, y = TFe_mgL))+
  geom_point()

fcr_doc_formatted%>%
  ggplot(aes(x = Date, y = DOC_mgL))+
  geom_point()

vw2 = vw2%>%
  full_join(fcr_fe_formatted)%>%
  full_join(fcr_doc_formatted)%>%
  full_join(fcr_ghg_formatted)%>%
  mutate(all_c_umolL = co2_vw_umolL+ch4_vw_umolL)

write.csv(vw2, "../../DO_modeling_data/final_modeling_dataset.csv", row.names = F)
```
